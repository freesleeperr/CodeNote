# C# 基础

## 环境

#### VS

选择 c#终端新建

## 控制台

命令 ctrl+f5
Console.Write("")...

## 注释

与 js 相同
`# region`,`# endregion`折叠代码标签

## 变量

申明方式`变量类型 变量名 = 初始值`

#### 变量类型

##### 有符号的整形变量 能存储一定范围的正负数数值

sbyte:-128~127,占 1 字节
int:+-21 亿,占 4 字节
short:-32768~32767,占 2 字节
long:+-9 百万兆,占 8 字节

##### 无符号的整形变量

byte:0~255 占 1 字节
unit:0~24 亿 占 4 字节
ushort:0~65535 占 2 字节
ulong:0~18 百万,占 8 字节

##### 浮点数

特点:存小数,按照有效数字计算,超出的会四舍五入

float:存储 7~8 位有效数字,数字最后要加`f`,因为默认为 double 类型,占 4 个字节
double:存储 15~17 位有效数字,占 8 个字节
decimal:存储 27~28 的有效数字,数字最后要加`m`,占 16 个字节 128 位

##### 特殊类型

bool:表示真假的类型
char:存储单个字符的变量类型 2 个字节，表示 1 个 Unicode 字符
string:字符串

_变量可以没有初始值,但是不建议_

#### 变量的本质

所占的内存越大,存储的信息越多
本质:二进制的 0 和 1
1byte=8bit(8 个 0/1)

2 进制转 10 进制
10 进制转 2 进制

对于有符号的,左侧第一位存储符号

#### 命名规则

不能重名
不能以数字开头
不能使用关键字
不能有特殊符号

#### 声明常量

const
`const int mynumber = 13`

1. 必须初始化(必须提供一个值)
2. 不得被修改

在游戏中用于定义不会变化的数值

#### 转义字符

用途: 显示特殊符号

固定写法\
常用写法:

- 双引号\"
- 单引号\'
- 换行\n
- 斜杠\\
- 制表符\t 看起来像 4 个空格
- 光标退格\b
- 空字符\0
- 警告音\a
- 取消转义字符@

#### 隐式转换

##### 无符号的隐式转换

ulong>unit>ushort>byte

大范围的可以存储小范围的值,变量的类型也会发生改变

##### 有符号的隐式转换

long>int>short>sbyte
相同与无符号

##### 浮点数的隐式转换

double>float>所有整型(无符号+有符号) decimal(无法隐式转换)

##### 不同类型转换

- 特殊类型无法转换
- 有符号的变量无法转换成无符号的数
- 无符号的数在不超出范围的情况下可以转换为有符号的数
- 浮点数可以装任何类型的整数(double,float)

- decimal 可以隐式存储所有整形(无符号+有符号)
- bool 无法隐式转换

- char 可以隐式转换为整型和浮点型(ascii 码)
- 一个字符对应一个数字编码
- string 无法隐式转换

##### 总结

- 高精度转换为低精度
- double>float>整型>char
- decimal>整型>char
- long>int>short>sbyte
- ulong>unit>ushort>byte
- 无符号>X 有符号
- 有符号>无符号(范围必须符合)

#### 显式转换

##### 括号强转

把高精度转换为低精度,可以避免报错
变量类型 变量名 = (变量类型)变量
`double i = 1.1234831352511f`强行转为 float
`i2 = (float)i`

- 在强行转换时注意范围,否则会有异常
- 浮点数强转整形会丢失小数点后的数字
- bool&string 不能通过括号强转

##### Parse 法

- 把字符串类型转换为对应的类型
  `变量类型.Parse("字符串")`

##### Convert 法

`int a = Convert.ToInt32("12")`

- 精度比括号强转好,会四舍五入
- bool 也可以转
- 每个类型都有对应的转换方法

##### 其他类型转 string

拼接打印
`str= "123"+1+true`
`str=a.toString(123)`

#### 错误捕获

```
try{

}catch{

}finall{

}
```

## 运算

#### 运算符

在运算浮点数时需要加 f
取余运算`%`
运算符逻辑跟 js 相似
`++`
第一种形式是前缀增量操作。 该操作的结果是操作数加 1 之后的值。

第二种形式是后缀增量操作。 该运算的结果是操作数增加之前的值,操作数加 1。

- 计算连续++时,值为上一次++后数值

##### 字符串拼接

字符串无法运算但是可以使用+/+=拼接
或者`string.Format("待拼接的{0}",{1}...,str0,str1...)

##### 条件运算

- 返回 bool 类型的值,`<,>,==`
- 先计算再比较
- 不能比较范围
- 特殊类型和相同类型比较

#### 位运算

连接两个数值进行计算,将数值转换为二进制

1. 位与
   `&` 遇 0 侧零
2. 位或
   `|` 有 1 侧 1
3. 异或
   `^` 相同位为 1,否则 0
4. 取反
   `~` 0 变为 1,如果第一位为符号位,正负也会改变
5. 左移
   `<<`左移几位,右侧加几个零
   `>>`右移几位,右侧去掉几个数

#### 三元运算

`string str=false?"t":"f"`

- 必须要保证真假结果的类型是一致的

#### 条件分支语句

```
if(bool){
if(bool){

}

}else if(bool){

}else{

}
```

#### Switch

从上向下执行语句

```
switch(常数){
   case 常数:
   Console.WriteLine("a为1");
   break;
   ...
   default:
      break;
}
```

条件等于== case 会执行当前语句

##### 贯穿

当满足某些条件时,做的事情一样,就可以贯穿

```
switch(常数){
   case 常数:
   case 常数2:
   Console.WriteLine("a为1");
   break;
   ...
   default:
      break;
}
```

#### 循环语句

##### while

当代码执行完,会回到 while

死循环,可能造成程序卡死

bool 可以使用作为条件
break 直接跳出循环,包括死循环
continue 回到循环一开始

##### do...while

先执行一次,再进行判断再决定是否继续

```
do{
   Console.Write(a)
   ++a
}while(a,2)
```

##### for

```
for(/初始表达式/,/条件表达式/,/增量表达式/){
//循环代码逻辑
};
for(int i = 0,i<10,i++>){
   Console.WriteLine(i);
};
//for循环条件可以省略来产生死循环
for(int i = 0,,i++>){
   Console.WriteLine(i);
   while(i>20){
      break;
   }
};
```

for 循环可以准确得到一个范围中的所有数

## 总结

1. 讲练结合
2. 培养良好的学习习惯
3. 培养程序思维

做题,实践+思考

# C# 基础

## 复杂数据类型

特点: 1.数据集合
一般是多个是数据(变量集合再一起的数据) 2.自定义
一般可以自己取名字,可以自定义

- 枚举:整形常量的集合
- 数组:任意变量类型的顺序存储的顺序
- 结构体: 任意变量的数据集合

## 枚举

被命名的整形变量的集合
一般用来表示状态,类型...

#### 声明枚举&声明枚举变量

声明枚举:创建一个自定义枚举类型
声明枚举变量:使用声明的自定义枚举类型,创建一个枚举变量

#### 声明语法

名字: 以 `E`或者`E_`开头,作为命名规范

```
enmu E_自定义枚举名{
   //从零默认向下累加
   自定义枚举名字0,
   自定义枚举名字1,
   自定义枚举名字2,
};
```

若改变默认枚举序号

```
enmu E_自定义枚举名{
   //从零默认向下累加,从1开始累加
   自定义枚举名字0=1,
   自定义枚举名字1,
   自定义枚举名字2,
};
```

##### 声明枚举的位置

- 声明在 namespace 区域
- 在 class,struct 语句块中
- 不得在函数语句块中声明

##### 声明枚举变量

```
enum E_MyMonster
    {
        Normal,//0
        Boss,//1

    };
enum E_Player
    {
        Wizard = 3,
        Knight,

    };

E_PlayerType mainPlayer = E_Player.wizard;
```

#### 结合 switch 使用

```
switch(mainPlayer){
   case E_Player.Wizard:
   //dosomething wizard
   break
   case E_Player.Knight:
   //dosomething knight
   break
};
```

#### 类型转换

##### 与 int 互相转换

`int a = (int)mainPlayer`

##### 与 string 互相转换

//枚举转换为 string
`string str= playerType.Tostring();`
//string 转换为枚举
`playerType =(E_PlayerType)Enum.Parse(typeof(E_PlayerType),"Wizard");`

#### 枚举的作用

表示状态时，可以把数字和描述结合起来，用作标识状态的含义。

## 数组

#### 基本概念

一维,多维,交错数组

#### 数组声明

1. 声明但是未初始化
   `变量类型[] 数组名;`
2. 声明并初始化,长度确定,用 0 填充
   `变量类型[] 数组名 = new 变量类型[数组的长度]`
3. 声明并确定对象
   `变量类型[] 数组名 = new 变量类型[数组长度]{内容}`
4. 内容确定数组长度
   `变量类型[] 数组名 = new 变量类型[]{内容}`
5. 内容确定数组长度,省略[]
   变量类型[] 数组名 = {内容 1,内容 2....}

#### 数组的使用

1. 数组的长度
   `array.length()`
2. 获取数组中的元素
   `array[0]`
   从下标和索引获取,注意不能越界,否则会报错
3. 修改数组中的元素
   `array[0]= 0`
4. 遍历数组 通过循环 快速获取数组

   ```
   for(int i=0;i<array.Length;i++){
     Console.WriteLine(array[i]);
   };
   ```

5. 增加数组的元素
   `int[] array2 = new int[6];`
   数组初始化后不可以添加元素,但是可以进行搬家操作,把原数组放到新的数组中
   ```
   for(int i=0;i <array.length;i++){
     array2[i] = array[i];
   }
   ```
   把原数组放到新的数组中，来增加数组项
6. 删除数组的元素
   原理与增加相同，但是长度变为新`array.length`
7. 查找数组中的元素
   遍历所有数组项目，再进行对应

##### 总结

1. 同一变量的数据集合
2. 需要的操作，声明，遍历，增删查改
3. 所有变量类型都可以声明为数组
4. 用于批量存储同一类型对象的，比如所有的怪物、玩家。。。

## 二位数组

同时具有行,列属性的数组

#### 二维数组的声明

1. 类型`[,]`,`[行数,列数]`
2. 未初始化`int arr[,]`
3. 初始化`int [,] arr2 = new int[3,3]`3 行 3 列
4. 初始化并确定内容 `int [,] arr2 = new int[3,3]{{1,2,3},{3,4,5},{7,8,9}}`

#### 二维数组的操作

1. 获取长度

```
// 获取行
Console.WriteLine(array.GetLenght(0));
//获取列
Console.WriteLine(array.GetLenght(1));
```

2. 获取二维数组的元素
   `array[0.,0]`
   获取第零行第零列
3. 修改二位数组
   `array[0,0] = 3`
4. 遍历二维数组
   通过嵌套循环来进行遍历

```
for (int i = 0;i<array.GetLength(0);i++){
   for (int j = 0;j<array.GetLength(1);j++){
   Console.WriteLine(array[i,j])
   }
}
```

5. 增加，减少数组
   同一维数组，利用搬家的方式进行操作
   创建目标数组，遍历原数组赋值

#### 总结

1. 同一变量类型的行列数据综合
2. 声明，遍历，增删改查
3. 所有的变量可以声明为二维数组
4. 一般用来存储矩阵，也可以当作地图格子

## 交错数组

不常用
数组的数组,类型：`[][]`,`[,][,]`,`[][,]`,`[,][]`

行数确定,列数不确定
`int[][] arr = new int[][]`

## 引用和值类型

#### 使用的区别

值类型: `int a =10;`无符号整形,有符号整形,浮点数,char,bool,结构体
引用类型:`int[] arr2=arr;`,`string a = "hello,world"`数组(一维,二维,交错) string 类

值类型:内容被拷贝,但是内容没有关联(他变我不变)
引用类型:两者指向同一类型(它变我也变)

#### 原因

值类型和引用类型存储的地方不同

- 值存储在栈中-系统分配,自动回收,小而快
- 引用存储在堆空间中-手动申请和释放,大而慢

#### 特殊的引用类型 String

String 虽然是引用类型,但是具有值类型的特征

频繁改变 string 会产生内存垃圾,原来的内存会保留

## 函数

#### 基本概念

本质是一块有名称的代码块
可以使用函数名称的方法执行该代码块
封装函数可以重复使用

#### 主要作用

1. 封装代码
2. 提升代码复用率
3. 抽象行为

#### 声明位置

class/struct 语句块中

#### 基本语法

```
static 返回类型 参数名（类型0 参数名0，类型1 参数名1）{
   函数代码逻辑；
   // 可选，有返回类型才需要返回
   return 返回值

}
```

- static 不是必须的，类和结构体
- void 表示没有返回值
- 返回类型可以写任意的变量类型， 14 种变量类型 + 复杂数据类型（数组，结构体，类 class）
- 使用 Pascal 命名，MyName
- 参数类型也可是任意类型
- 参数命名采用驼峰命名，myName
- 参数不是必须的，多个参数需要用逗号隔开

- 当返回值非 void ，必须 return 相应类型，viod 时也可选 return

#### 返回值类型

1. 有参有多返回值

```
static int[] Cal(int a, int b){
   int svm;
   int avg = sum/2;
   return new int[]{svm,avg}
}
```

- 前提是使用者知道规则
- 返回值可以用表达式
- return 可以不执行之后的代码,直接返回函数外部
